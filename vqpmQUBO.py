'''
QPM converges the eigenvector of I+U with the maximum magnitude 
that is max |1+e^{i\lambda}|, where \lambda is the minimum eigenvalue of H.
The file includes two implementations of variational quantum power method (vqpm), 
vqpmForQUBO, vqpmForQUBO2 they both finds the minimum eigenphase of u indicated by imin 
for the further explanation please refer to the paper...
note: you can run by changing example input at the end.
@author: adaskin
'''

import numpy as np
import matplotlib.pyplot as plt
from vqpmUtilities import   prepareNewState, print_debug
if __name__ == '__main__':
    pass

DEBUG = False



def applyUH(psi, u, N):
    #apply Hadamard to 1st qubit in reg0
    s2 = 1/np.sqrt(2)

    for indx0 in range(0, int(N/2)): #first qubit is in ket{1}
        indx1 = indx0+N  #1st qubit is '1'
        #apply Hadamard 
        temp0 = psi[indx0]*s2
        temp1 =  psi[indx1]*s2*u[indx0]
    
        psi[indx0] = temp0 + temp1 # where p0 in ket{0}
        psi[indx1] = temp0- temp1  # where p1 in ket{1}
    return psi

   
def vqpmForQUBO(u, n, maxiter, imin,  pdiff, precision):
    '''
    applies vqpm to given u representing the solution space of a QUBO,
    prepares new state from the measurement output at each iteration
    u: QUBO instance
    n: number of parameter qubits
    maxiter: max number of iteration
    imin: index of expected minimum of u, used to print probs at each iteration
    Note: this version uses whole quantum state which is may be slowere than the second version below
    '''
    Pimin = np.zeros(maxiter, float);
    N = 2 ** n;
    m = n +1 #total number of qubits (n+1 for parameters, n+1 for constraint register)
    M = 2**m; #the size of whole system 
    
    Md2= int(M/2)
   
    
    #the state generated by using thetas 
    inVec = np.ones((N, ), dtype=complex) / np.sqrt(N); 
 
    numOfIter = maxiter;
  
    qStates ={} 
    s2 = 1/np.sqrt(2)
    inH = np.array([s2, s2], dtype=complex)
    IN = np.zeros(N,complex); IN[0] = 1

    for j in range(0, maxiter):
        ###################################
        #######prepare initial state
        psi = np.kron(inH, inVec)
      
        if(DEBUG):
            print_debug("initial  psi:", psi, m)

            
        ####################################### 
        # apply CUv on reg0
        psi = applyUH(psi,u, N);
            
        if(DEBUG):
            print_debug("UV psi:", psi, m)
        
        ###############################################
        #measure the first qubit 
        psi0 = psi[0:Md2] #first qubit in \ket{0}
        psi1 = psi[Md2: M] #first qubit in \ket{1}
        
        p0 = np.linalg.norm(psi0); # compute P0 for first qubit
        p1 = np.linalg.norm(psi1)
      
        psi0 = psi0/p0
        psi1 = psi1/p1
        
        if(DEBUG):
            print_debug("collapsed psi0:", psi0, n)
        
        ####################################### 
        # new state for next iteration
        inVec,qStates = prepareNewState(psi0,n,qStates, pdiff, precision)  
   
        if(DEBUG): 
            print_debug("prepared new state:", inVec,n)
        
        
        
        Pimin[j] = np.abs(inVec[imin]) ** 2;
        print("iter: %d probOof1stqubit: %f probofTargetInCollapsedState: %lf" % (j, p0, Pimin[j]));
        if (Pimin[j] >= 0.5):
            numOfIter = j + 1;
            break;
            
    stateProb = np.max(inVec)
    foundState = np.argmax(inVec)  
    
    
    return   foundState, stateProb, qStates, p0, numOfIter,  Pimin[0:numOfIter];

def vqpmForQubo2(u, n, maxiter, iexpected,  pdiff, precision):
    '''
    measures the state at each iteration
    '''
    Pimin = np.zeros((maxiter,), float);
    N = 2 ** n;
    s2 = 1 / np.sqrt(2); 
    inVec = np.ones((N, ), dtype=complex) / np.sqrt(N); 
    psi2 = np.zeros((N, ), dtype=complex);
    numOfIter = maxiter;

    qStates={}    
    for j in range(0, maxiter):
        
       
        # HoI*initial
        psi1 = inVec * s2;
        # print(np.abs(u))
        # print(np.abs(psi1))
        # apply CU
        for k in range(0, N):
            psi2[k] = u[k] * psi1[k];
        
        # print('psi2:') 
        # print(np.abs(psi2))
        # apply Hadamard
        psi11 = np.add(s2 * psi1, psi2 * s2);
        # psi21 = s2 * psi1 - s2 * psi2;
        
        p0 = np.linalg.norm(psi11);
        # p1 = np.linalg.norm(psi21);
        
        inVec = psi11 / p0;        
        
        Pimin[j] = np.abs(inVec[iexpected]) ** 2;
        print("iter: %d probO Of 1st qubit: %f prob Of Expected State: %lf" % (j, p0, Pimin[j]));
        if (Pimin[j] >= 0.5):
            numOfIter = j + 1;
            break;
            
        inVec,qStates = prepareNewState(inVec,n,qStates,  pdiff, precision)
   
        
    psi21 = np.add(s2 * psi1, s2 * psi2);
    
    final_probs = np.power(np.abs(psi11), 2) + np.power(np.abs(psi21), 2);
    
    stateProb = np.max(final_probs)
    foundState =np.argmax(final_probs)  
    
    
    return   foundState, stateProb, qStates, p0, numOfIter,  Pimin[0:numOfIter]
  

def unitaryForQubo(n, c, Q):
    '''
    creates a vector which represents the diagonal of U
    '''    
    # function u = unitaryforQubo(n, c,Q)
    # x {0, +1}
    # for given coefficients c and number of parameters n, it creates a diagonal
    # unitary whose elements encode the solution space. it returns a vector.
    N = 2 ** n;
    u = [1];
    # \sum cixi
    for i in range(0, n):
        ui = [1, np.exp(1j * c[i] )];
        u = np.kron(u, ui);
    
    # \sum hij xixj
    for i in range(0, n - 1):
        for j in range(i + 1, n - 1):
            qij = np.exp(1j * Q[i][j] );
            
            for k in range(0, N - 1):
                b1 = bin(k)[2:];
                b1 = b1.zfill(n);
                if  (b1[i] == 1) and (b1[j] == 1):
                    u[k] = u[k] * qij;
    return u


def randomQ(n):
    '''for agiven n parameters it generates a random coefficient matrix Q
    its diagonal should be considered as c
    '''
    Q = np.random.randn(n, n); Q = Q + np.transpose(Q);
    maxQ = np.sum(np.sum(np.abs(np.tril(Q, 0))));
    Q = Q / (maxQ); 
    return Q;


#def main(u, n): 
pdiff = 0.001 #necessary prob diff to assume a qubit 1 or 0
precision = 4 #precision of measurement outcome
n = 15;  # upto20
Q = randomQ(n)*np.pi/4; #the sum in [-pi/4, pi/4]
c = np.diagonal(Q);
u = unitaryForQubo(n, c, Q);
u = np.exp(1j * np.pi/4) * u;  # the sum in [0, pi/2] always positive



lu = np.real(np.log(u) / (1j));
  

expectedState = np.argmin(lu);

foundState, stateProb, qStates, p0, numOfIter,  Pimin = vqpmForQubo2(u, n, 50, expectedState,  pdiff, precision);
#foundState, stateProb, qStates, p0, numOfIter,  Pimin = vqpmForQUBO(u, n, 50, expectedState,  pdiff, precision)
print("-------------------------------------")
print("Eigenvalues in [%f, %f]" % (np.min(lu), np.max(lu)))
print("Expected and Found Eigenvalues")

print("expected  value:%f, state:%d" % (lu[expectedState], expectedState))
print("found     value:%f, state:%d with prob:%f" % (lu[foundState], foundState, stateProb))
sortedlu = np.sort(np.abs(lu));
print("eigengap: ", sortedlu[1]-sortedlu[0])
print(sortedlu)

fig = plt.figure()
plt.plot(range(numOfIter), Pimin,'b.')
plt.ylabel('iteration')

plt.xlabel('the success probability (the eigengap: %f, 1/2^n: %f)' 
           %(sortedlu[1]-sortedlu[0], 1/2**n))
plt.show()

 
#fig.savefig('destination_path.eps', format='eps', dpi=1000)
